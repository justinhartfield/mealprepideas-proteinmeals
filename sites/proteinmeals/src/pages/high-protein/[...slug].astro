---
/**
 * proteinmeals.co/high-protein/[...slug] â€” Two-Facet Combo Catch-all (T3)
 * Uses NEW combo components instead of legacy TwoFacetCombo
 */
import DietGoalCombo from '@mealprepideas/shared/components/DietGoalCombo.astro';
import PersonaMethodCombo from '@mealprepideas/shared/components/PersonaMethodCombo.astro';
import MethodMealCombo from '@mealprepideas/shared/components/MethodMealCombo.astro';
import RetailConstraintCombo from '@mealprepideas/shared/components/RetailConstraintCombo.astro';
import { generateTwoFacetPaths, slugToDisplay } from '@mealprepideas/shared/utils/urls';
import type { FacetKey } from '@mealprepideas/shared/data/taxonomy';

export function getStaticPaths() {
  const paths = generateTwoFacetPaths('high-protein');
  return paths.map(({ slug, facetA, facetB }) => ({
    params: { slug: slug.join('/') },
    props: { facetA, facetB },
  }));
}

interface Props {
  facetA: { type: FacetKey; value: string };
  facetB: { type: FacetKey; value: string };
}

const { facetA, facetB } = Astro.props;
const displayA = slugToDisplay(facetA.value);
const displayB = slugToDisplay(facetB.value);

const placeholderRecipes = Array.from({ length: 6 }, (_, i) => ({
  id: i + 1,
  title: `${displayA} ${displayB} Recipe ${i + 1}`,
  protein: `${28 + i * 3}g`,
  cal: `${420 + i * 40}`,
  method: facetA.type === 'method' ? facetA.value : facetB.type === 'method' ? facetB.value : 'batch-cook',
  tag: ['High Fiber', 'Budget', 'Quick', 'Freezer-Friendly', 'Comfort', 'Classic'][i],
  score: 9.8 - i * 0.3,
}));

const placeholderFaqs = [
  { question: `How do I combine ${displayA} with ${displayB} effectively?`, answer: `Our system optimizes the intersection of ${displayA.toLowerCase()} and ${displayB.toLowerCase()} for maximum nutritional benefit and prep efficiency.` },
  { question: `How long do these meals store?`, answer: `Most protocols are optimized for 5-day fridge life. Freezer-friendly variants extend to 90 days.` },
];

const siblings = [
  { href: `/high-protein/${facetA.type}/${facetA.value}/`, label: `${displayA} Hub`, sublabel: `All ${displayA} protocols` },
  { href: `/high-protein/${facetB.type}/${facetB.value}/`, label: `${displayB} Hub`, sublabel: `All ${displayB} protocols` },
];

// Route to appropriate T3 component based on facet types
const isRetailCombo = facetA.type === 'store' || facetA.type === 'chain' || facetB.type === 'store' || facetB.type === 'chain';
const isPersonaMethod = facetA.type === 'persona' || facetB.type === 'persona';
const isDietGoal = (facetA.type === 'diet' || facetB.type === 'diet') && (facetA.type === 'goal' || facetB.type === 'goal');
const isMealMethod = facetA.type === 'meal' || facetB.type === 'meal';

const sharedProps = {
  hub: 'high-protein' as const,
  facetA, facetB,
  title: `${displayA} ${displayB} Protocols | ProteinMeals.co`,
  description: `${displayA} meets ${displayB}. High-protein protocols at the intersection.`,
  canonicalUrl: `https://proteinmeals.co/high-protein/${facetA.type}/${facetA.value}/${facetB.type}/${facetB.value}/`,
  headline: displayA,
  headlineAccent: `${displayB} System`,
  subheadline: `Solving the intersection of ${displayA.toLowerCase()} and ${displayB.toLowerCase()} with data-backed prep protocols.`,
  recipes: placeholderRecipes,
  faqs: placeholderFaqs,
  siblings,
};
---

{isRetailCombo ? (
  <RetailConstraintCombo {...sharedProps} />
) : isPersonaMethod ? (
  <PersonaMethodCombo {...sharedProps} />
) : isMealMethod ? (
  <MethodMealCombo {...sharedProps} />
) : (
  <DietGoalCombo {...sharedProps} />
)}
